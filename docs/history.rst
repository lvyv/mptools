.. include:: ../HISTORY.rst

2021.12.22
当前配置的主要问题和解决的方案。
配置下发的时候，一种是针对单视频通道的配置下发，一种是针对所有视频通道的全配置文件下发。两种情况都需要支持热更新整个程序，按照新的配置工作。
1）针对单通道的配置下发。
已解决。
2）针对多通道配置的下发。
已解决。
3）遗留问题。
配置信息的热更新。

热更新的方案：
a.不重启进程，而是改rtsp进程的那些控制参数。
b.统计一下rtsp，ai，mqtt都会用哪些控制参数呢：
ai-不需要配置，所有信息是rtsp发来的。

mqtt-需要，涉及到服务器重新连接等操作，破坏了原基类假定的startup，loop，shutdown三步，需要在基类进行改造。
mqtt比较简单，只要重新连接服务器就可以了。
*已经OK。mqtt线程能够自动重启，当收到配置更新的消息时候。
主要的实现方案：在startup中，找主进程要配置信息，要到后把自己关心的配置信息全部设置为成员变量，然后连接mqtt服务器，如果出错，抛出V2V异常。
procworker基类主循环不处理异常，继续抛给基类，基类发现是V2V异常，就重新启动新一轮循环。
这种实现方案有两个地方会触发本进程重启，即：1）收到配置信息更新；2）刚开始启动的时候出现配置错误（因为捕获了所有的线程，所以不会退出。
已经回归测试，能够发送stop的时候，退出流水线。


rtsp-需要。
此前的方案是在创建进程的时候给pipeline分配任务参数，比如url，mqtt的连接地址等。这样在重新启动的时候就比较难处理，
最理想的方式是启动的流水线应该为无任务绑定的。当任务来了以后，流水线自己取领取任务。也就是在创建任务的时候，只是启动了若干流水线，
在startup的时候，大家取获取任务。如果任务分配完，就算了。

1)rtsp采用GrabFrame去取流。
2)rtsp多个进程去要任务，任务列表分配在stop pipe line 和 下发配置的时候被清空。
3)rtsp进程多于实际任务，空闲进程会休息5秒再去要求工作。
4)rtsp进程少于实际任务，...
测试要求，先测正常下发功能，再测正常后断网恢复，再测开始断网后恢复。
1)rtsp进程多于等于新下发任务数，预期：多的子进程休息5秒，重新申请任务，测试通过。（OK）
2)rtsp进程少于新下发任务数，新任务不被执行，但配置更新，重新stop，start整个管道流水线，会按照新的任务数量启动进程执行。（OK）
3)第1/2个测试场景，正常流水线执行态，断网，恢复网络。（OK）
4)第1/2个测试场景，先断网，启动流水线，恢复网络。（OK）

GrabFrame的错误恢复机制被设计为：1）只要open_stream成功，以后read_frame如果不成功，就会再次启动内部线程去重连。这样能避免在上层
处理网络不稳定中断的情况。2）如果刚开始没有配置对或连不成功，则直接返回错误，不做多余的恢复处理。这个错误的恢复交给上层业务，上层调用，
发现不成功，则再重调用就行了。

c.不管是rtsp还是mqtt，如果不重启进程，就需要重写基类的run的逻辑。为了最大限度保持原来逻辑不变，采用抛出异常的方案。
当procworker基类在mainloop中执行main_func的时候，如果收到广播的配置更改的消息，则抛出一个自定义的异常。在基类run中处理。

2021.12.23
1）在rest的presets的路由调用时，进行处理，先通知主进程暂停，然后开始，最后再恢复。

2021.12.24
处理配置文件的热更新问题。


2021.12.25
当前通道配置aoi的时候，会临时取得摄像头的控制权，这会打断识别流水线，之后再释放控制权。
并且要支持多任务之间的互斥。
